# 前端性能优化指南

智慧医养平台前端性能优化最佳实践和实施指南。

## 📋 目录
- [路由懒加载](#路由懒加载)
- [组件懒加载](#组件懒加载)
- [虚拟滚动](#虚拟滚动)
- [图片优化](#图片优化)
- [状态管理优化](#状态管理优化)
- [请求优化](#请求优化)

---

## 🚀 路由懒加载

### ✅ 已实现
项目已经使用动态导入实现了路由懒加载：

```javascript
// ✅ 正确：使用动态import
{
  path: 'list',
  name: 'ElderlyList',
  component: () => import('@/views/elderly/list.vue'),
  meta: { title: '老人档案列表', icon: 'list' }
}
```

### ⚠️ 避免
```javascript
// ❌ 错误：静态导入会打包到主bundle
import ElderlyList from '@/views/elderly/list.vue'

{
  path: 'list',
  component: ElderlyList
}
```

### 📦 代码分割优化
使用魔法注释为路由模块分组：

```javascript
// 将相关路由打包到同一个chunk
{
  path: 'list',
  component: () => import(/* webpackChunkName: "elderly" */ '@/views/elderly/list.vue')
},
{
  path: 'detail/:id',
  component: () => import(/* webpackChunkName: "elderly" */ '@/views/elderly/Detail.vue')
}
```

---

## 🎯 组件懒加载

### 1. 大型组件按需加载

```vue
<script setup>
import { defineAsyncComponent } from 'vue'

// 懒加载大型图表组件
const HealthStatisticsDialog = defineAsyncComponent(() => 
  import('@/components/HealthStatisticsDialog.vue')
)

const CareStatisticsDialog = defineAsyncComponent(() => 
  import('@/components/CareStatisticsDialog.vue')
)

const AssessmentReportDialog = defineAsyncComponent({
  loader: () => import('@/components/elderly/AssessmentReportDialog.vue'),
  loadingComponent: LoadingComponent, // 可选：加载时显示的组件
  errorComponent: ErrorComponent, // 可选：加载失败时显示的组件
  delay: 200, // 延迟显示loading组件的时间
  timeout: 3000 // 超时时间
})
</script>

<template>
  <!-- 只有在打开对话框时才加载组件 -->
  <AssessmentReportDialog v-if="showDialog" />
</template>
```

### 2. 标签页内容懒加载

```vue
<script setup>
import { ref, defineAsyncComponent } from 'vue'

const activeTab = ref('basic')

// 按标签页懒加载
const tabs = {
  basic: defineAsyncComponent(() => import('./tabs/BasicInfo.vue')),
  health: defineAsyncComponent(() => import('./tabs/HealthInfo.vue')),
  records: defineAsyncComponent(() => import('./tabs/HealthRecords.vue'))
}
</script>

<template>
  <el-tabs v-model="activeTab">
    <el-tab-pane label="基本信息" name="basic">
      <component :is="tabs.basic" />
    </el-tab-pane>
    <el-tab-pane label="健康信息" name="health">
      <component :is="tabs.health" />
    </el-tab-pane>
    <el-tab-pane label="健康记录" name="records">
      <component :is="tabs.records" />
    </el-tab-pane>
  </el-tabs>
</template>
```

---

## 📜 虚拟滚动实现

### 方案1: 使用 el-table 的虚拟滚动（Element Plus 2.4+）

```vue
<template>
  <el-table-v2
    :columns="columns"
    :data="tableData"
    :width="700"
    :height="400"
    fixed
  />
</template>

<script setup>
import { ref } from 'vue'

const columns = [
  { key: 'name', dataKey: 'name', title: '姓名', width: 150 },
  { key: 'age', dataKey: 'age', title: '年龄', width: 100 },
  { key: 'phone', dataKey: 'phone', title: '电话', width: 150 }
]

// 大量数据
const tableData = ref([/* ...thousands of rows */])
</script>
```

### 方案2: 使用 vue-virtual-scroller

```bash
npm install vue-virtual-scroller
```

```vue
<template>
  <RecycleScroller
    class="elderly-scroller"
    :items="elderlyList"
    :item-size="80"
    key-field="id"
    v-slot="{ item }"
  >
    <div class="elderly-item">
      <h3>{{ item.name }}</h3>
      <p>{{ item.healthStatus }}</p>
    </div>
  </RecycleScroller>
</template>

<script setup>
import { RecycleScroller } from 'vue-virtual-scroller'
import 'vue-virtual-scroller/dist/vue-virtual-scroller.css'
import { ref } from 'vue'

const elderlyList = ref([]) // 大量数据
</script>

<style>
.elderly-scroller {
  height: 600px;
}

.elderly-item {
  height: 80px;
  padding: 10px;
  border-bottom: 1px solid #eee;
}
</style>
```

### 方案3: 简单的分页加载（推荐现阶段使用）

```vue
<script setup>
import { ref, onMounted } from 'vue'
import { getElderlyPage } from '@/api/elderly'

const loading = ref(false)
const elderlyList = ref([])
const pagination = ref({
  current: 1,
  size: 20,
  total: 0
})

// 加载数据
const loadData = async () => {
  loading.value = true
  try {
    const res = await getElderlyPage({
      pageNum: pagination.value.current,
      pageSize: pagination.value.size
    })
    elderlyList.value = res.data.records
    pagination.value.total = res.data.total
  } finally {
    loading.value = false
  }
}

// 滚动加载更多（无限滚动）
const handleScroll = (e) => {
  const { scrollTop, scrollHeight, clientHeight } = e.target
  if (scrollTop + clientHeight >= scrollHeight - 10 && !loading.value) {
    if (elderlyList.value.length < pagination.value.total) {
      pagination.value.current++
      loadMore()
    }
  }
}

const loadMore = async () => {
  loading.value = true
  try {
    const res = await getElderlyPage({
      pageNum: pagination.value.current,
      pageSize: pagination.value.size
    })
    // 追加数据
    elderlyList.value.push(...res.data.records)
  } finally {
    loading.value = false
  }
}

onMounted(loadData)
</script>

<template>
  <div class="elderly-container" @scroll="handleScroll">
    <div v-for="item in elderlyList" :key="item.id" class="elderly-item">
      <!-- 老人信息卡片 -->
    </div>
    <div v-if="loading" class="loading">加载中...</div>
  </div>
</template>
```

---

## 🖼️ 图片优化

### 1. 图片懒加载

```vue
<template>
  <!-- 使用 v-lazy 指令（需安装 vue-lazyload） -->
  <img v-lazy="item.avatar" alt="头像" />
  
  <!-- 或使用原生 loading 属性 -->
  <img :src="item.avatar" loading="lazy" alt="头像" />
</template>
```

### 2. 响应式图片

```vue
<template>
  <img
    :srcset="`
      ${item.avatar}-small.jpg 300w,
      ${item.avatar}-medium.jpg 600w,
      ${item.avatar}-large.jpg 1200w
    `"
    sizes="(max-width: 600px) 300px, 
           (max-width: 1200px) 600px, 
           1200px"
    :src="item.avatar"
    alt="头像"
  />
</template>
```

### 3. 图片占位符

```vue
<script setup>
const defaultAvatar = '/images/default-avatar.png'
const handleImageError = (e) => {
  e.target.src = defaultAvatar
}
</script>

<template>
  <img 
    :src="item.avatar || defaultAvatar" 
    @error="handleImageError"
    alt="头像"
  />
</template>
```

---

## 💾 状态管理优化

### ✅ 最佳实践

#### 1. 避免在组件中存储重复数据

```javascript
// ❌ 不好：在多个组件中存储同一份数据
// Component A
const elderlyList = ref([...])

// Component B
const elderlyList = ref([...]) // 重复数据

// ✅ 好：使用 Pinia Store 统一管理
// stores/elderly.js
export const useElderlyStore = defineStore('elderly', {
  state: () => ({
    list: [],
    currentElderly: null
  }),
  actions: {
    async fetchList() {
      const res = await getElderlyPage()
      this.list = res.data.records
    }
  }
})
```

#### 2. 合理使用计算属性

```javascript
// ✅ 在 Store 中使用 getters
export const useElderlyStore = defineStore('elderly', {
  state: () => ({
    list: []
  }),
  getters: {
    // 自动缓存，只有依赖变化时才重新计算
    healthyCount: (state) => state.list.filter(e => e.healthStatus === 'HEALTHY').length,
    sickCount: (state) => state.list.filter(e => e.healthStatus === 'SICK').length,
    
    // 带参数的 getter
    getElderlyById: (state) => (id) => state.list.find(e => e.id === id)
  }
})
```

#### 3. 避免存储冗余数据

```javascript
// ❌ 不好：存储派生数据
{
  state: () => ({
    elderlyList: [],
    healthyList: [],  // 冗余
    sickList: []      // 冗余
  })
}

// ✅ 好：使用 getters 计算派生数据
{
  state: () => ({
    list: []
  }),
  getters: {
    healthyList: (state) => state.list.filter(e => e.healthStatus === 'HEALTHY'),
    sickList: (state) => state.list.filter(e => e.healthStatus === 'SICK')
  }
}
```

---

## 🌐 请求优化

### 1. 请求防抖

```javascript
import { debounce } from 'lodash-es'

// 搜索框防抖
const searchElderly = debounce(async (keyword) => {
  const res = await getElderlyPage({ name: keyword })
  elderlyList.value = res.data.records
}, 300)
```

### 2. 请求取消

```javascript
import { ref } from 'vue'
import axios from 'axios'

const controller = ref(null)

const searchElderly = async (keyword) => {
  // 取消上一次未完成的请求
  if (controller.value) {
    controller.value.abort()
  }
  
  controller.value = new AbortController()
  
  try {
    const res = await axios.get('/api/elderly/search', {
      params: { keyword },
      signal: controller.value.signal
    })
    return res.data
  } catch (error) {
    if (axios.isCancel(error)) {
      console.log('请求已取消')
    }
  }
}
```

### 3. 请求缓存

```javascript
// utils/cache.js
const cache = new Map()
const CACHE_TIME = 5 * 60 * 1000 // 5分钟

export function cacheRequest(key, fetcher, ttl = CACHE_TIME) {
  const cached = cache.get(key)
  
  if (cached && Date.now() - cached.timestamp < ttl) {
    return Promise.resolve(cached.data)
  }
  
  return fetcher().then(data => {
    cache.set(key, {
      data,
      timestamp: Date.now()
    })
    return data
  })
}

// 使用
import { cacheRequest } from '@/utils/cache'

const loadElderlyList = () => {
  return cacheRequest('elderlyList', () => getElderlyPage())
}
```

### 4. 并发请求优化

```javascript
// ❌ 不好：串行请求
const elderly = await getElderlyById(id)
const healthRecords = await getHealthRecords(id)
const warnings = await getWarnings(id)

// ✅ 好：并行请求
const [elderly, healthRecords, warnings] = await Promise.all([
  getElderlyById(id),
  getHealthRecords(id),
  getWarnings(id)
])
```

---

## 📊 性能监控

### 使用 Performance API

```javascript
// utils/performance.js
export function measurePageLoad() {
  window.addEventListener('load', () => {
    const perfData = performance.getEntriesByType('navigation')[0]
    
    console.table({
      'DNS查询': perfData.domainLookupEnd - perfData.domainLookupStart,
      'TCP连接': perfData.connectEnd - perfData.connectStart,
      '请求响应': perfData.responseEnd - perfData.requestStart,
      'DOM解析': perfData.domInteractive - perfData.domLoading,
      '页面加载': perfData.loadEventEnd - perfData.loadEventStart,
      '总时间': perfData.loadEventEnd - perfData.fetchStart
    })
  })
}
```

### Vue DevTools 性能分析

1. 打开 Vue DevTools
2. 切换到 "Performance" 标签
3. 点击 "Start recording"
4. 执行需要分析的操作
5. 点击 "Stop recording"
6. 查看组件渲染时间和性能瓶颈

---

## ✅ 优化检查清单

- [ ] 所有路由都使用懒加载
- [ ] 大型组件使用异步组件
- [ ] 长列表使用虚拟滚动或分页
- [ ] 图片使用懒加载
- [ ] 合理使用 Pinia Store
- [ ] 避免组件内部过多业务逻辑
- [ ] 搜索框使用防抖
- [ ] 取消未完成的请求
- [ ] 使用请求缓存
- [ ] 并行发起独立请求
- [ ] 使用 keep-alive 缓存组件
- [ ] 避免不必要的响应式数据
- [ ] 使用生产环境构建
- [ ] 启用 Gzip 压缩
- [ ] 使用 CDN 加载第三方库

---

## 🚀 下一步

建议按以下顺序实施优化：

1. **立即执行**：
   - 检查路由懒加载是否完整
   - 为搜索框添加防抖

2. **短期优化**（1-2周）：
   - 实现关键列表的虚拟滚动
   - 优化图片加载

3. **中期优化**（1个月）：
   - 完善状态管理
   - 添加请求缓存

4. **长期优化**（持续）：
   - 性能监控和分析
   - 根据实际情况调整优化策略
