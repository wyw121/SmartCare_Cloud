# 缓存策略优化指南

智慧医养平台的缓存策略设计和优化建议。

## 📋 目录
- [Spring Cache配置](#spring-cache配置)
- [Redis缓存策略](#redis缓存策略)
- [缓存注解使用](#缓存注解使用)
- [缓存失效策略](#缓存失效策略)
- [性能监控](#性能监控)

---

## ⚙️ Spring Cache配置

### 当前配置（application.yml）

```yaml
spring:
  cache:
    type: redis
    redis:
      time-to-live: 600000  # 缓存过期时间(毫秒) 10分钟
      cache-null-values: false  # 不缓存空值
      
  redis:
    host: localhost
    port: 6379
    database: 0
    timeout: 10000ms
    lettuce:
      pool:
        max-active: 8
        max-wait: -1ms
        max-idle: 8
        min-idle: 0
```

### 优化建议配置

```yaml
spring:
  cache:
    type: redis
    redis:
      time-to-live: 3600000  # 提升至1小时
      cache-null-values: false
      use-key-prefix: true  # 使用key前缀
      key-prefix: "smartcare:"  # 统一key前缀
      enable-statistics: true  # 启用缓存统计
      
  redis:
    host: localhost
    port: 6379
    database: 0
    timeout: 10000ms
    lettuce:
      pool:
        max-active: 20  # 增加连接池大小
        max-wait: 5000ms  # 设置合理的等待时间
        max-idle: 10
        min-idle: 2
    # 启用自动重连
    lettuce:
      shutdown-timeout: 200ms
```

---

## 🎯 缓存策略设计

### 1. 不同数据的缓存时间

```java
/**
 * 缓存配置类
 */
@Configuration
@EnableCaching
public class CacheConfig {
    
    @Bean
    public CacheManager cacheManager(RedisConnectionFactory factory) {
        // 默认配置
        RedisCacheConfiguration defaultConfig = RedisCacheConfiguration.defaultCacheConfig()
                .entryTtl(Duration.ofMinutes(30)) // 默认30分钟
                .serializeKeysWith(RedisSerializationContext.SerializationPair.fromSerializer(
                        new StringRedisSerializer()))
                .serializeValuesWith(RedisSerializationContext.SerializationPair.fromSerializer(
                        new GenericJackson2JsonRedisSerializer()))
                .disableCachingNullValues(); // 不缓存null值
        
        // 为不同的cache name设置不同的过期时间
        Map<String, RedisCacheConfiguration> cacheConfigurations = new HashMap<>();
        
        // 基础数据：1小时（变化很少）
        cacheConfigurations.put("elderly",
                defaultConfig.entryTtl(Duration.ofHours(1)));
        cacheConfigurations.put("doctor",
                defaultConfig.entryTtl(Duration.ofHours(1)));
        cacheConfigurations.put("user",
                defaultConfig.entryTtl(Duration.ofHours(1)));
        
        // 统计数据：10分钟（需要较高实时性）
        cacheConfigurations.put("statistics",
                defaultConfig.entryTtl(Duration.ofMinutes(10)));
        cacheConfigurations.put("dashboard",
                defaultConfig.entryTtl(Duration.ofMinutes(10)));
        
        // 健康记录：30分钟（中等实时性）
        cacheConfigurations.put("healthRecord",
                defaultConfig.entryTtl(Duration.ofMinutes(30)));
        
        // 配置数据：24小时（几乎不变）
        cacheConfigurations.put("config",
                defaultConfig.entryTtl(Duration.ofHours(24)));
        cacheConfigurations.put("dict",
                defaultConfig.entryTtl(Duration.ofHours(24)));
        
        // 预警数据：5分钟（高实时性）
        cacheConfigurations.put("healthWarning",
                defaultConfig.entryTtl(Duration.ofMinutes(5)));
        
        return RedisCacheManager.builder(factory)
                .cacheDefaults(defaultConfig)
                .withInitialCacheConfigurations(cacheConfigurations)
                .transactionAware()
                .build();
    }
}
```

---

## 📝 缓存注解最佳实践

### 1. @Cacheable - 查询缓存

```java
@Service
public class ElderlyServiceImpl extends ServiceImpl<ElderlyMapper, Elderly> implements ElderlyService {
    
    /**
     * 根据ID查询老人信息（带缓存）
     * 
     * key格式: elderly::id:{id}
     * 过期时间: 1小时
     */
    @Cacheable(value = "elderly", key = "'id:' + #id", unless = "#result == null")
    @Override
    public Elderly getById(Serializable id) {
        return super.getById(id);
    }
    
    /**
     * 查询重点关注老人（带缓存）
     * 
     * key格式: elderly::keyList
     * 过期时间: 10分钟
     */
    @Cacheable(value = "statistics", key = "'keyElderlyList'")
    public List<Elderly> getKeyElderlyList() {
        return lambdaQuery()
                .eq(Elderly::getHealthStatus, "WARNING")
                .or()
                .eq(Elderly::getHealthStatus, "DANGER")
                .list();
    }
    
    /**
     * 健康统计（带缓存）
     * 
     * 使用condition避免无效缓存
     */
    @Cacheable(
        value = "statistics",
        key = "'healthStats'",
        condition = "#useCache == true",
        unless = "#result == null"
    )
    public Map<String, Object> getHealthStatistics(boolean useCache) {
        // 统计逻辑
        return statistics;
    }
}
```

### 2. @CachePut - 更新缓存

```java
@Service
public class ElderlyServiceImpl extends ServiceImpl<ElderlyMapper, Elderly> implements ElderlyService {
    
    /**
     * 更新老人信息（同时更新缓存）
     * 
     * 注意：@CachePut总是执行方法，然后更新缓存
     */
    @CachePut(value = "elderly", key = "'id:' + #elderly.id")
    @Override
    public boolean updateById(Elderly elderly) {
        boolean success = super.updateById(elderly);
        if (success) {
            // 发布事件，清除相关缓存
            eventPublisher.publishEvent(new ElderlyUpdatedEvent(this, elderly.getId()));
        }
        return success;
    }
}
```

### 3. @CacheEvict - 清除缓存

```java
@Service
public class ElderlyServiceImpl extends ServiceImpl<ElderlyMapper, Elderly> implements ElderlyService {
    
    /**
     * 删除老人（清除缓存）
     */
    @CacheEvict(value = "elderly", key = "'id:' + #id")
    @Override
    public boolean removeById(Serializable id) {
        return super.removeById(id);
    }
    
    /**
     * 批量删除（清除所有相关缓存）
     */
    @CacheEvict(value = "elderly", allEntries = true)
    public boolean removeBatchByIds(Collection<? extends Serializable> idList) {
        return super.removeBatchByIds(idList);
    }
    
    /**
     * 清除统计缓存（定时任务）
     */
    @CacheEvict(value = "statistics", allEntries = true)
    @Scheduled(cron = "0 */10 * * * ?") // 每10分钟清除一次
    public void clearStatisticsCache() {
        log.info("定时清除统计缓存");
    }
}
```

### 4. @Caching - 组合缓存操作

```java
@Service
public class ElderlyServiceImpl extends ServiceImpl<ElderlyMapper, Elderly> implements ElderlyService {
    
    /**
     * 新增老人（清除统计缓存，不缓存结果）
     */
    @Caching(evict = {
        @CacheEvict(value = "statistics", allEntries = true),
        @CacheEvict(value = "dashboard", allEntries = true)
    })
    public boolean save(Elderly elderly) {
        return super.save(elderly);
    }
    
    /**
     * 更新老人健康状态（更新缓存+清除统计）
     */
    @Caching(
        put = {
            @CachePut(value = "elderly", key = "'id:' + #elderly.id")
        },
        evict = {
            @CacheEvict(value = "statistics", allEntries = true)
        }
    )
    public boolean updateHealthStatus(Elderly elderly) {
        return super.updateById(elderly);
    }
}
```

---

## 🔄 缓存失效策略

### 1. 事件驱动的缓存清除

```java
/**
 * 老人更新事件
 */
public class ElderlyUpdatedEvent extends ApplicationEvent {
    private final Long elderlyId;
    
    public ElderlyUpdatedEvent(Object source, Long elderlyId) {
        super(source);
        this.elderlyId = elderlyId;
    }
    
    public Long getElderlyId() {
        return elderlyId;
    }
}

/**
 * 缓存清除监听器
 */
@Component
public class CacheEvictListener {
    
    @Autowired
    private CacheManager cacheManager;
    
    /**
     * 监听老人更新事件，清除相关缓存
     */
    @EventListener
    public void onElderlyUpdated(ElderlyUpdatedEvent event) {
        // 清除统计缓存
        Cache statisticsCache = cacheManager.getCache("statistics");
        if (statisticsCache != null) {
            statisticsCache.clear();
        }
        
        // 清除仪表板缓存
        Cache dashboardCache = cacheManager.getCache("dashboard");
        if (dashboardCache != null) {
            dashboardCache.clear();
        }
        
        log.info("老人信息更新，已清除相关缓存，elderlyId: {}", event.getElderlyId());
    }
}
```

### 2. 缓存预热

```java
@Component
public class CacheWarmer implements CommandLineRunner {
    
    @Autowired
    private ElderlyService elderlyService;
    
    @Autowired
    private DoctorService doctorService;
    
    @Override
    public void run(String... args) {
        log.info("开始缓存预热...");
        
        // 预热热点数据
        elderlyService.getKeyElderlyList();
        elderlyService.getHealthStatistics(true);
        doctorService.getDoctorList();
        
        log.info("缓存预热完成");
    }
}
```

### 3. 缓存穿透防护

```java
@Service
public class ElderlyServiceImpl extends ServiceImpl<ElderlyMapper, Elderly> implements ElderlyService {
    
    /**
     * 防止缓存穿透
     * 使用布隆过滤器或缓存空对象
     */
    @Cacheable(
        value = "elderly",
        key = "'id:' + #id",
        unless = "#result == null",  // null值不缓存，防止缓存穿透
        condition = "#id != null"
    )
    public Elderly getByIdWithBloomFilter(Long id) {
        // 1. 先检查布隆过滤器（可选）
        if (!bloomFilter.mightContain(id)) {
            return null; // 肯定不存在
        }
        
        // 2. 查询数据库
        return super.getById(id);
    }
}
```

---

## 📊 性能监控

### 1. 缓存统计信息

```java
@RestController
@RequestMapping("/api/monitor")
public class CacheMonitorController {
    
    @Autowired
    private CacheManager cacheManager;
    
    /**
     * 获取缓存统计信息
     */
    @GetMapping("/cache/stats")
    public Map<String, Object> getCacheStats() {
        Map<String, Object> stats = new HashMap<>();
        
        Collection<String> cacheNames = cacheManager.getCacheNames();
        for (String cacheName : cacheNames) {
            Cache cache = cacheManager.getCache(cacheName);
            if (cache instanceof RedisCache) {
                stats.put(cacheName, getCacheInfo((RedisCache) cache));
            }
        }
        
        return stats;
    }
    
    private Map<String, Object> getCacheInfo(RedisCache cache) {
        Map<String, Object> info = new HashMap<>();
        info.put("name", cache.getName());
        // 更多统计信息...
        return info;
    }
    
    /**
     * 清除指定缓存
     */
    @DeleteMapping("/cache/{cacheName}")
    public ResponseResult<Void> clearCache(@PathVariable String cacheName) {
        Cache cache = cacheManager.getCache(cacheName);
        if (cache != null) {
            cache.clear();
            return ResponseResult.success("缓存清除成功");
        }
        return ResponseResult.error("缓存不存在");
    }
}
```

### 2. Redis监控命令

```bash
# 连接Redis
redis-cli

# 查看所有key
KEYS smartcare:*

# 查看key的过期时间
TTL smartcare:elderly::id:1

# 查看内存使用
INFO memory

# 查看缓存命中率
INFO stats

# 监控命令执行
MONITOR

# 查看慢查询
SLOWLOG GET 10
```

---

## ✅ 缓存优化检查清单

### 设计阶段
- [ ] 识别需要缓存的数据（读多写少、计算复杂）
- [ ] 确定合理的缓存过期时间
- [ ] 设计缓存key的命名规范
- [ ] 考虑缓存失效策略

### 实现阶段
- [ ] 正确使用@Cacheable、@CachePut、@CacheEvict
- [ ] 设置合理的condition和unless条件
- [ ] 使用事件驱动清除相关缓存
- [ ] 实现缓存预热机制

### 运维阶段
- [ ] 监控缓存命中率
- [ ] 监控Redis内存使用
- [ ] 定期清理无用缓存
- [ ] 压测验证缓存效果

---

## 🚨 常见问题和解决方案

### 1. 缓存雪崩

**问题**：大量缓存同时失效

**解决方案**：
```java
// 为不同的key设置随机过期时间
@Cacheable(value = "elderly", key = "'id:' + #id")
public Elderly getById(Long id) {
    // 在CacheConfig中设置
    // .entryTtl(Duration.ofMinutes(30 + new Random().nextInt(10)))
    return super.getById(id);
}
```

### 2. 缓存击穿

**问题**：热点key失效，大量请求打到数据库

**解决方案**：
```java
// 使用分布式锁
@Cacheable(value = "statistics", key = "'hotData'", sync = true)
public Object getHotData() {
    // sync=true 会使用同步锁
    return expensiveOperation();
}
```

### 3. 缓存与数据库不一致

**解决方案**：
```java
// 方案1：先删除缓存，再更新数据库
@Transactional
public void updateElderly(Elderly elderly) {
    // 1. 删除缓存
    cacheManager.getCache("elderly").evict("id:" + elderly.getId());
    
    // 2. 更新数据库
    updateById(elderly);
    
    // 3. 再次删除缓存（延迟双删）
    CompletableFuture.runAsync(() -> {
        try {
            Thread.sleep(500);
            cacheManager.getCache("elderly").evict("id:" + elderly.getId());
        } catch (InterruptedException e) {
            log.error("延迟删除缓存失败", e);
        }
    });
}
```

---

## 🎯 优化建议总结

1. **合理设置过期时间**：根据数据特点设置不同的TTL
2. **使用事件驱动**：通过事件自动清除相关缓存
3. **避免过度缓存**：不要缓存所有数据，选择合适的数据
4. **监控缓存效果**：定期查看命中率和性能提升
5. **防止缓存问题**：考虑雪崩、击穿、穿透等问题
6. **定期清理**：清理无用或过期的缓存key
